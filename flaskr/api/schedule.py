# -*- coding: utf-8 -*-
"""Bojangles GA Algorithm PoC.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sei9n9P8ZAuqFboRYmHx_nULnfwVLMzc

By Adam Yi <i@adamyi.com> and Chester Pang <i@bopa.ng>
"""

import json
import sys
import random
# import matplotlib.pyplot as pyplot
import numpy

from tqdm import tqdm

exp = numpy.exp

# GA variables
POP_SIZE    = 500
GENERATIONS = 100
MUTATION_CHANCE = 100

HOUR_LOWER = 0
HOUR_UPPER = 7*24

# read data

def read_data(ccodes, db):
    """
    Read classutil.json and return list of comps (each containing classes)
    Given input of a list of course codes
    """
    data = db

    courses = []

    for ccode in ccodes:
        # spec_name = ccode[0:4]
        # spec = (spec for spec in data if spec["specialisation"] == spec_name and spec["session"] == 'S2').next()
        # courses.append((course for course in spec["courses"] if course["course"] == ccode).next())
        courses.append(data[ccode])

    # print(json.dumps(courses, indent = 4))


    # output: comps = [[cls for classes in unique comp]]
    comps = []
    for course in courses:
      course_comp = []
      for cls in course['classes']:
        course_comp.append(cls['comp'])
      for comp in set(course_comp):
        comps.append([cls for cls in course['classes'] if cls['comp'] == comp])

    return comps



# Fitness Function

def get_hours_bound(comps, population):
    DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
    ftp = {day: [] for day in DAYS}
    minimum = 0
    maximum = 7*24
    for dna in population:
        _, _, hrs, _, _ = get_fitness_vals(comps, dna, ftp)
        minimum = hrs if minimum > hrs else minimum
        maximum = hrs if maximum < hrs else maximum
    return minimum, maximum


def get_fitness_vals(comps, dna, freetimepref):
  """
  Return course hour clash, total days, total hours, and
  hours clashed with user's preferenced free time (e.g. sleeping time,
  dating time, etc.)
  """
  DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
  occupied = {day: [] for day in DAYS}
  hours = {day: 0 for day in DAYS}
  course_clash = 0
  ftp_clash = 0
  totalHours = 0
  for i in range(len(comps)):
    for time in comps[i][dna[i]]['times']:
      if not time['hours']: #e.g. web lectures
        continue
      # TODO: deal with time with minutes (e.g. 11:30)
      start = int(time['hours']['start'])
      end = int(time['hours']['end'])
      totalHours += end - start
      hours[time['day']] += end - start
      for hr in range(start, end):
        if hr in occupied[time['day']]:
          course_clash += 1
        if hr in freetimepref[time['day']]:
          ftp_clash += 1
        occupied[time['day']].append(hr)
  days = len([day for day in DAYS if occupied[day]])
  if numpy.count_nonzero(hours.values()) == 1:
    variance = 0
  else:
    avg = sum(hours.values())
    avg /= numpy.count_nonzero(hours.values())
    variance = sum([(hours[day] - avg) ** 2 if hours[day] > 0 else 0 for day in DAYS]) / (numpy.count_nonzero(hours.values()) - 1)

  return course_clash, days, totalHours, ftp_clash, variance

# evaluate for each param
day_table = {1: 100, 2: 100, 3: 100, 4: 50, 5: 0}

# x should be # of min
clash_value = lambda x: max([-13.7*exp(-0.01*x*60)+113.6*exp(-0.02*x*60), 0])
day_value = lambda x: day_table[x]
hr_value = lambda x: (HOUR_UPPER-x)*1.0/(HOUR_UPPER - HOUR_LOWER) * 100
diff_value = lambda x: 0.25*x*x-10.25*x+100

def fitness(comps, dna):
  """
  Where the magic happens.

  The evaluation function of a class schedule (dna).
  The bigger the fitness value, the better the class schedule is.

  TODO: make this really fancy
  """
  DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
  ftp = {day: [18, 19, 20, 21, 8, 9, 10] for day in DAYS}

  course_clash, day, hr, ftp_clash, var = get_fitness_vals(comps, dna, ftp)
  return clash_value(course_clash) + day_value(day) + hr_value(hr) * 0.0 + clash_value(ftp_clash) + diff_value(var)

# GA algorithm

def random_int(size):
  """
  Return a random int from 0 to size - 1
  """
  return random.randint(0,size - 1)

def random_population(comps):
  """
  Return the initial random population of DNAs by randomizing.
  """
  pop = []
  for i in range(POP_SIZE):
    dna = []
    for c in range(len(comps)):
      dna.append(random_int(len(comps[c])))
    pop.append(dna)
  return pop

def roulette_select(dnas):
  """
  Choose a random dna by imitating the process of finding a girlfriend with
  standards gradually lowered.

  Disclaimer: this might not be a universal fact for finding your loved one.
  We are not responsible for using this algorithm to find a date. Use at your
  own risk ^_^

  * This is actually an O(n) approach to the Fitness Proportionate Selection
  * problem.
  """
  fitness_total = sum((dna[1] for dna in dnas))
  criteria = random.uniform(0, fitness_total)
  for dna, fitness in dnas:
    if criteria < fitness:
      return dna
    criteria -= fitness

  return dna

def crossover(dna1, dna2):
  """
  Slices two DNAs at a random index and swaps one part to generate two newborn
  DNAs.
  """
  pos = int(random.random() * len(dna1))
  return (dna1[:pos] + dna2[pos:], dna2[:pos] + dna1[pos:])

def mutate(comps, dna):
  """
  Copy a DNA while randomly mutating it with chance 1/MUTATION_CHANCE
  """
  dna_out = []
  for gl in range(len(comps)):
    if int(random.random() * MUTATION_CHANCE) == 1:
      dna_out.append(random_int(len(comps[gl])))
    else:
      dna_out.append(dna[gl])
  return dna_out

def generate_schedule(courses, db, verbose=False):
  if not verbose:
    sys.stdout = open('schedule.log', 'a')
    sys.stderr = sys.stdout
  comps = read_data(courses, db)

  population = random_population(comps)
  HOUR_LOWER, HOUR_UPPER = get_hours_bound(comps, population)

  fits = []
  mean_fits = []

  DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
  ftp = {day: [18, 19, 20, 21, 8, 9, 10] for day in DAYS}

  for generation in tqdm(range(GENERATIONS)):
    try:
        max_fit = max(weighted_population, key=lambda pair: pair[1])
        fits.append(get_fitness_vals(comps, max_fit[0], ftp))
        mf = (0,0,0,0,0)
        for ind in weighted_population:
          mf = tuple(x + y for x, y in zip(mf, get_fitness_vals(comps, ind[0], ftp)))
        mean_fits.append(mf)
        # print "Generation %s: max_fit = '%s' fitness: %s" % \
        #     (generation, json.dumps(max_fit), fits[-1])
    except Exception as e:
        print(e)


    weighted_population = [[dna, fitness(comps, dna)] for dna in population]
    population = []

    for _ in range(int(POP_SIZE / 2)):
      # Selection
      dna1 = roulette_select(weighted_population)
      dna2 = roulette_select(weighted_population)

      # Crossover
      dna1, dna2 = crossover(dna1, dna2)

      # Mutate and add back into the population.
      population.append(mutate(comps, dna1))
      population.append(mutate(comps, dna2))

    HOUR_LOWER, HOUR_UPPER = get_hours_bound(comps, population)

  weighted_population = [[dna, fitness(comps, dna)] for dna in population]
  fittest_schedule = max(weighted_population, key=lambda pair: pair[1])

  return {
          'schedule': fittest_schedule,
          'comps': comps
          }

  # fits.append(fittest_schedule)
  # print "Fittest in all gens: %s" % json.dumps(max(fits, key=lambda pair: pair[1]))

  # x = range(len(fits))
  # pyplot.plot(x,[pair[0] for pair in mean_fits], label='course clash hour')
  # pyplot.plot(x,[pair[1] for pair in mean_fits], label='number of day')
  # pyplot.plot(x,[pair[2] for pair in mean_fits], label='total hours')
  # pyplot.plot(x,[pair[3] for pair in mean_fits], label='ftp clash hour')
  # pyplot.plot(x,[pair[4] for pair in mean_fits], label='variance')
  # pyplot.legend()
  # pyplot.show()

if __name__ == "__main__":

  if (len(sys.argv) == 1):
    print("Usage: ./%s COMP1511 MATH1131......" % sys.argv[0])
    sys.exit(1)

  db = json.load(open('classutil.json'))
  generate_schedule(sys.argv[1:], db, True)
